# network
## protocol
    컴퓨터와 컴퓨터가 네트워크를 이용하여 통신을 하기 위해 정해놓은 데이터 통신을 위한 규칙의 집합.  
    ex)TCP/IP  
- - -
## network model
    자동차를 만들 때 단계를 나누어서 순차적으로 제작이 이루어 진다.  
    왜냐하면, 이 방법이 훨씬 시간이 적게 들고, 일의 능률이 올라간다.  
    네트워크도 마찬가지 이다. 단계를 나누어서 통신을 하면 통신의 능률이 올라갈 것이다.  
    이 때문에 프로토콜을 계층화 시켰다.    
    프로토콜의 각 계층의 기능을 실현하는 계체(?) --> 프로토콜의 각 계층을 엔티티라고 한다(entity)
    각 계층은 하위 계층에서 서비스(신호)를 받고 상위층에 서비스(신호)를 보낸다.  
    이렇게, 상위계층과 하위계층의 통신규약을 인터페이스라고 하고, 같은계층에서 통신할때의 약속을 프로토콜이라고 한다.  
- - -
## OSI 참조모델 
    국제표준화기구(OSI)가 OSI모델을 발표하였다. --> 어떤 두 시스템이 구조와 상관없이 서로 통신할 수 있게 해주는 protocol  
<img src="https://madplay.github.io/img/post/2018-02-17-network-osi-7-layer-1.png"/>
위의 사진이 OSI protocol이다.  
총 7계층으로 나누어져 있으며, 계층이 올라갈 때 마다 자기 계층이라는 것을 알리는 header가 붙고, 이것을 캡슐화 라고 한다.  
계층을 내려갈 때는 header가 사라지고, 디캡슐화 라고 한다.  

* 물리계층(1계층)  
    물리계층은 단말기기(전자기기)와 전송매체(인터넷선,wifi) 사이의 인터페이스를 담당함  
    전기적인 신호 --> 정보 or 정보 --> 전기적인 신호  
    예를 들면...네트워크 어뎁터랑 리피터가 있다.    

* 데이터 링크 계층(2계층)  
    물리적 주소를 구분하고, 데이터 전송 형태를 지정하는 계층이다.
    신호를 다듬고, MAC주소로 통신이 가능하게 하는 곳이 2계층이다.
    브리지,스위치가 2계층이다.

* 네트워크 계층(3계층)  
    논리적 주소를 구분하고, 목적지까지 데려다 주는 계층.  
    IP/ARP등등이 프로토콜의 예시이고, 기기로는 라우터가 있다.

* 전송 게층(4계층)
    데이터 전송 방식을 결정하고, 포트 번호를 구분하는 계층.  
    전송방식에는 TCP와 UDP가 있다.  
    TCP --> 데이터를 보내면 데이터가 제대로 갔는지, 요청을 보내서 확인.  
    UDP --> 그냥 데이터를 계속 보내고 확인도 안함.  
    protocol --> TCP,UDP  
    port --> http(80),ftp(20 --> 연결,21 --> 파일 전송),telnet(23)  

* 세션계층(5계층)
    통신 경로 확립,단절,전송방식을 지정

* 표현계층(6계층)
    7계층에서 만들어진 데이터에 확장자를 붙여줌. 그리고 데이터의 동일한 형식을 지원해줌.  

* 응용계층(7계층)
    user interface를 지원함  
- - - 
## TCP/IP 프로토콜
    현재는 OSI프로토콜보다 TCP/IP 프로토콜을 더 많이 사용한다.
    그 이유는 먼저 나왔기 때문이고, 개방적이고, 표준화되는 프로토콜이 실제로 사용가능한 프로토콜인지 중시한다는 점이 대중화를 이끌었다.  
OSI계층과 비교하면 이 사진과 같을 것이다.
<img src="https://mblogthumb-phinf.pstatic.net/MjAxODA0MDlfMTIy/MDAxNTIzMjcyNzE3Nzgy.JONryPAIL3Zz5YizEyEM7nGVjCmBnLSHyz0aPk2mfWgg.kSLOlqPQiC5zGm3VH4veVzWfOdDQ4SdvFInD149CfRQg.PNG.zkdxhd10823/tcpip.PNG?type=w800">  
- - -
## 통신방식의 종류
* 커넥션형
    커넥션형은 전화 통신과 같이 상대방의 전화번호를 입력하여, 상대가 전화를 받으면 대화를 하는 것과 비슷 --> 회선교환  --> 품질은 좋아지는데 한 선을 계속 잡고 사용하니까 베타적임.
* 커넥셕리스형
    우체국에서 수취인의 주소를 확인하거나 수취인이 우편물을 받았는지 모르는 상태에서 받은 이에게 우편물을 배달하는 것과 비슷 --> 실시간  --> 패킷교환 패킷은 1500바이트
* 유니캐스트 --> 1대1
* 브로드캐스트 --> 1대 다수 --> 나와 연결된 모든 것에 다 날려버린다 2말이야  ex) 랜선꼽앗는데 어디서 통신보낼지 모르는데 어디서 보냈는지 알아내기 위해서 한번 다 보내고 돌아오는 거 확인하는데 다 보내는게 브로드 캐스트  --> 브로드 캐스트는 게이트웨이를 넘어 갈 수 없다. --> 
브로드 캐스트가 오면 내부망 안오면 외부망
* 멀티캐스트 --> 특정 그룹 내 통신 --> 네트워크 디바이스 --> 라우터끼리 통신을 멀티캐스트를 함  
* 애니캐스트 --> dns --> naver.com을 치면 네이버 서버에 연결시켜 주는 거 --> naver.com에다가 통신 때리면 먼저 대답해서 데려가는 게 dns   
#### broadcast,unicast,multicast  
<img src="https://t1.daumcdn.net/cfile/tistory/2721A1505783B03519">  

#### anycast -> dns 구동방식  
<img src="https://cdome.comodo.com/images-new/home/what-is-dns.png">  

- - -
## http
    browser에서 사용되는 네트워크 프로토콜의 하나이다.  
    보통 80port를 사용한다.  
    TCP 방식을 사용하기 때문에,  return값이 돌아오는데, 3자리 숫자로 나누어져 있다.  
    100대 --> 정보의 제공  
    200대 --> 긍정적인 대답
    300대 --> 전송 요구(성공은 했는데, 이렇게 보내주면 보안에도 좋고 더 보기 좋을거 같다고 말하는 것임)  
    400대 --> 클라이언트 오류(front-end 다 죽는다!!)
    500대 --> 서버오류(back-end 다 죽는다!!)  
    자세한 내용은 밑의 사진을 확인하자
<img src="https://t1.daumcdn.net/cfile/tistory/1327B40B4C6B9E4D13"> 

### http의 구동방식
    사용자가 url을 입력 --> web browser가 url을 해독 
<img src="http://ibiblio.org/team/intro/URL/urlparts.gif">
    해독한 후에 어디로 http를 보내야 하는지 판명이 되면 어떻게, 무엇을 보낼지 골라야 한다. --> method를 골라야 함.    
<img src="https://cdn-images-1.medium.com/max/1200/1*J19iyqcti8JFVSfnbSj5nA.png">  

    GET: 서버에 통신을 보내 서버에서 정보를 요청하는 형태  
    POST: 서버에 통신을 보내 정보를 보내는 형태  
    HEAD: GET과 비슷한 형태이지만, 헤더 정보 이외에 아무것도 보내지 않음.  
    OPTIONS: 서버에 method를 이용해 통신하기 이전에, 서버가 지원하는  method가 무엇인지 확인하는 method(server에서 무조건적으로 지원)  
    다른 것들은 거의 사용하지 않는다.  
    
    이렇게 method를 이용하여 서버에 통신을 보내면, 서버에서 request값이 넘어온다.
    이 request값을 보고 다시 response를 보내고 다시 request를 받는 식으로, 통신을 이어간다. 모든 통신이 끝나면 TCP연결이 종료된다.  